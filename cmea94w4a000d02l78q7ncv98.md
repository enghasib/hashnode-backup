---
title: "Object Oriented Programming Part -1"
seoTitle: "Introduction to Object Oriented Programming"
seoDescription: "Learn OOP basics with practical examples: classes, objects, and memory architecture for efficient software design"
datePublished: Wed Aug 13 2025 17:36:09 GMT+0000 (Coordinated Universal Time)
cuid: cmea94w4a000d02l78q7ncv98
slug: introduction-of-object-oriented-programming
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1755106419882/a87c8a0e-e56d-4c66-a5ea-767eb38f6464.png
tags: oop, oops, object-oriented-programming, oop-design-principles

---

## OOP কী, কেন প্রয়োজন, Class ও Object, আর তাদের Memory Architecture

আপনি সফটওয়্যার বানানোর সময় প্রায়ই দু’টো বড় চ্যালেঞ্জের সম্মুখীন হবেন— প্রথম হলো **complexity** আর দ্বিতীয় হলো **code changes**। কোড যত বড় হয়, কোড বোঝো, চেঞ্জ করা, bug ফিক্স করা তত কঠিন হতে থাকে।

**Object-Oriented Programming (OOP)** এমন এক programming style যেখানে আপনি বাস্তব জগতের জিনিসকে **object** হিসেবে মডেল করেন—প্রতিটি object-এর **state** (ডেটা) আর **behavior** (ফাংশন/মেথড) থাকে। এতে করে কোড হয় সুসংগঠিত, reusable, testable—আর changes isolate করা সহজ হয়।

একটি বাস্তব analogy দিয়ে বোঝা যাক: ধরুন আপনি একটি **Clinic Management** সিস্টেম বানাচ্ছেন। আপনার কাছে **Doctor**, **Patient**, **Appointment**, **Prescription**—এসব আলাদা আলাদা **“Entity”** আছে। OOP-তে প্রতিটি এনটিটিকে কে আপনি object হিসেবে ধরবেন; তাদের ডেটা থাকবে (যেমন Patient-এর name, age) আর কাজ থাকবে (যেমন Appointment.schedule())। এতে পুরো সিস্টেমটা মাথায় রাখা, এবং বোঝা সহজ হয়—কারণ এখানে প্রতিটি অংশের দায়িত্ব পরিষ্কার থাকে।

---

## মূল ধারণা: Class ও Object

### Class কী?

**Class** হলো **blueprint**—একটি টেমপ্লেট যা বলে দেয় এই টাইপ-এর object-গুলো কেমন হবে: কী কী **property/field** থাকবে, এবং কী কী **method** থাকবে।  
যেমন আপনি একটি বাড়ি বানানোর **নকশা** কল্পনা করতে পারেন। যেখানে নকশা নিজে বাড়ি নয়; কিন্তু বাড়ি কেমন হবে তা নির্ধারণ করে।

### Object কী?

**Object** হলো ওই class-এর **instance** বা বাস্তব রূপ —রিয়েল জগতের একটা জিনিস। প্রতিটি object-এর নিজস্ব **state** বা ডেটা (যেমন color: “red”, speed: 60) এবং নিজস্ব **identity** থাকে। প্রত্যেকটি object একটি আরেকটি থেকে আলাদা।

যেমন ধরুন, নকশা ধরে **আপনার নিজের একটি ফ্ল্যাট** তৈরি করলেন —ফ্ল্যাটটি কিন্তু আসল, যার অস্তিত্ব আছে। সেটা ফিজিক্যালি এক্সিস্ট করে, সেখানে আপনি থাকতে পারেন। সুতরাং এই নকশা ব্যবহার করে বানানো এই ফিজিক্যাল **entity**\-ই হলো object।

---

## OOP কেন প্রয়োজন?

1. **একটি ইউনিটে রূপান্তর করতে**: ভিতের সব কিছুকে একটি সিঙ্গেল ইউনিট রূপান্তর করে। ভিতরের ডাটা গুলে কে প্রাইভেট করে রাখতে। উদাহরণ: **ওয়াটার পিউরিফায়ার**—আপনি শুধু একে একটি পানির সোর্স দিয়ে দেন; সে ভেতরে পানি কেমনভাবে purify করে তা আপনার জানতে হয়না, আপনি জাস্ট পিউরিফাইড পানি সেখান থেকে পান।
    
2. **জটিল কাজ গুলোকে সহজ করে উপস্থাপন করতে**: জটিল কাজ গুলোকে ইউজারের কাছ থেকে হাইড করে শুধু মাত্র ইউজারের প্রয়োজন অনুযায়ি ব্যবহারে আনুমতি দেয়। উদাহরণ: **লাইট সুইচ**—ভিতরে যে তার ও জটিল সার্কিট আছে আমাদের প্রয়োজন সেগুলো সম্পর্কে জানার, আপনি শুধু সুইচে চাপ দেন এবং লাইট জলতে শুরু করে।
    
3. **এক জিনিসের গুণ অন্য জিনিসে ব্যবহার করতে**: এক জনের বৈশিষ্ট্যে কিছু অংশ জন্যে মধ্যে নিয়ে আসে। উদাহরণ: **আপনার বাবা → আপনি → আপনার ছেলে**। আপনার বাবার কিছু বৈশিষ্ট্য আপনি পেয়েছেন। এবং আপনার কিছু বৈশিষ্ট্য আপনার ছেলে পাবে।
    
4. **একই কাজের ভিন্ন ভিন্ন ধরন**: একই ধরণের কাজ আলাদা জিনিস ভিন্নভাবে করতে পারে, আর ব্যবহারকারী জানে না ভিতরে কীভাবে হচ্ছে।  
    উদাহরণ: **পেমেন্ট সিস্টেম**—একই **পেমেন্ট**\* bKash একভাবে করে , Nagad একভাবে করে, আবার কার্ড অন্য ভাবে করে।
    

---

## Class বনাম Object — Memory Architecture (ধারণাগত চিত্র)

> নোট: নিচের আলোচনা **conceptual**—ভাষাভেদে (Java, C++, JavaScript, Go, Python, .NET) internals বদলাতে পারে। উদ্দেশ্য হলো **মনে রাখার মতো ছবি** তৈরি করা।

### Conceptual Overview

* **Code/Metadata Area**: আপনার class definition, method code, type information এখানে থাকে (যেমন JVM-এ **Metaspace**, .NET-এ **Method Table**, C++-এ **vtable** ইত্যাদি)।
    
* **Heap**: runtime-এ তৈরি হওয়া **object**\-গুলো সাধারণত এখানে থাকে; Garbage Collector (GC) এই এলাকার memory manage করে (ভাষাভেদে GC বা manual)।
    
* **Stack**: function call-গুলোর **local variable**, **return address**, **temporary** ডেটা থাকে; scope শেষ হলে stack frame pop হয়।
    

### Class কোথায় থাকে?

* Class হলো **static metadata + method code**। প্রোগ্রাম লোড হলে loader/runtime class info মেমোরিতে রাখে—method গুলোর address, field layout, কখনো কখনো **vtable**/**itable** (virtual dispatch table), constant pool, ইত্যাদি।
    
* এই অংশ **একবারই** লোড হয়; হাজার object বানালেও class metadata একটাই কপি থাকে।
    

### Object কোথায় থাকে?

* Object (বা struct) **Heap** বা **Stack** — দু'জায়গায়ই allocate হতে পারে; এটা নির্ভর করে compiler-এর Escape Analysis এর উপর।
    
* যদি কোনো object ফাংশন কল শেষে বাইরে ব্যবহার হয়, তাহলে সেটা Heap-এ থাকে।
    
* Stack ফ্রেমে object-এর **value copy** বা **pointer** রাখা হয়।
    
* প্রতিটি instance এর জন্য আলাদা memory allocation হয়।
    

উদাহরণঃ **Stack = ক্যাশ কাউন্টার**, যেখানে আপনি token (reference) নেন; **Heap = গুদামঘর**, যেখানে আসল জিনিস (object) রাখা।

---

## ছোট্ট কোড দেখে নিই

### JavaScript (class syntax)

```js
class Car {
  constructor(color) {
    this.color = color;     // field/state
    this.speed = 0;
  }
  accelerate(delta) {       // behavior/method
    this.speed += delta;
  }
  info() {
    return `${this.color} car @ ${this.speed} km/h`;
  }
}

const myCar = new Car("red");  // Object on Heap, reference in variable
myCar.accelerate(20);
console.log(myCar.info());     // "red car @ 20 km/h"
```

**বিঃদ্রঃ** JavaScript is not a Object Oriented Programming Language, It's a Functional Programming Language

---

## Design প্র্যাকটিস: কখন কীভাবে OOP ব্যবহার করবেন

1. **Single Responsibility**: একটি class/object-এর **একটি** একটিই কাজ করবে —তাহলে logic গুলিয়ে যাওয়া সম্ভাবনা কম থাকে না।
    
2. **Encapsulation first**: field/implementation detail private/unexported রাখতে; বাইরে **clean method**/interface দিতে চাইলে।
    
3. **Composition over Inheritance**: Code এর reuse করার ক্ষেত্রে; যদিও multi-level inheritance chaining অনেক সময় পেইন হতে পারে।
    
4. **Domain-Driven model** ভাবুন: **Ubiquitous Language**—আপনার domain terms (Doctor, Patient, Appointment) class/object এর নামের মাধ্যমেই তাদের কাজ বুঝে যাওয়া যায়।
    

**কখন OOP কম দরকার?**  
ডাটা-transform heavy কাজ (ETL, analytics pipeline), ছোট script, বা purely functional style-এ—যে কোনো জায়গায় OOP জোর করে বসানো উচিত না।

---

## Class/Object নিয়ে আরও কিছু খুঁটিনাটি

* **Identity vs Equality**: দুই object-এর field একই হলেও **identity** আলাদা হতে পারে। কারণ Reference equality ও value equality আলাদা বিষয়।
    
* **Constructor/Initializer**: object তৈরি ও valid state-এ আনার উপায়। Go-তে idiomatic ভাবে `NewType(...)` function।
    
* **Destructor/Finalizer/GC**: ভাষাভেদে resource cleanup আলাদা; GC থাকলে deterministic নয়—external resource (file/socket) তাড়াতাড়ি বন্ধ করতে **defer/close** ব্যবহার করুন।
    
* **Immutability**: সম্ভব হলে state কম বদলান; predictable behavior পেতে immutable data pattern কাজে দেয়।
    

---

## সারসংক্ষেপ

OOP আপনাকে **বাস্তব জগতের ধারণা** দিয়ে সফটওয়্যার মডেল করতে সাহায্য করে— OOP এর মেইন যে concept **encapsulation**, **abstraction**, **polymorphism**, **composition** এই টেকনিক গুলো ব্যবহার করে আপনার coder complexity একবারে ছোট ছোট টুকরে ভেঙে ফেলতে পারবেন। যেটা আপনের ডেভেলপমেন্টকে সহজ এবং আরাম দায়ক করে তুলবে।

এই পর্বে শুধু মাত্র OOP এর introduction দেওয়ার চেষ্টা করেছি। আগামী পর্বে থেকে ইনশাআল্লাহ OOP এর চার পিলার নিয়া আলোচনা করবো।

শেয়ার করতে ভুলবেন না। ধন্যবাদ